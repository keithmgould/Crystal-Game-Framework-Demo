<!DOCTYPE html>
<html>
 <head>
  <meta charset="UTF-8">
  <title>Crystal Api</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/documentation.css" />
 </head>
 <body>
  <section id="sidebar">
    <a class="toc_title" href="#server">Server</a>
    <ul class="toc_section">
      <li>- <a href="#socketConnected">s socketConnected</a></li>
      <li>- <a href="#socketDisconnected">s socketDisconnected</a></li>
      <li>- <a href="#messageFromClient">s messageFromClient</a></li>
      <li>- <a href="#messageToClient">p messageToClient</a></li>
      <li>- <a href="#broadcast">p broadcast</a></li>
    </ul> 
    <a class="toc_title" href="#client">Client</a>
    <ul class="toc_section">
      <li>- <a href="#messageToServer">p messageToServer</a></li>
      <li>- <a href="#messageFromServer">s messageFromServer</a></li>
      <li>- <a href="#enableDebugDraw">p enableDebugDraw</a></li>
    </ul>
    <a class="toc_title" href="#common">Common</a>
    <ul class="toc_section">
      <li>- <a href="#addEntity">p addEntity</a></li>
      <li>- <a href="#removeEntity">p removeEntity</a></li>
      <li>- <a href="#update">s update</a></li>
    </ul>
  </section>
  <section id="content">
    <h1>CRYSTAL.JS</h1>
    <p>
      Crystal is a real-time "twitch" game framework.  It offers features normally found only in enterprise game engines, such as client side prediction, entity interpolation and server-side lag compensation.  It utilizes the mediator pattern to communicate with your game, and the API is described below.
    </p>
    <h2>Server Side API</h2>
    <p id="socketConnected">
      <b class="header">socketConnected</b><code>Subscribe("socketConnected", function (data) {})</code>
      data object contains:
      <ul>
        <li>socketId: string.  Socket ID of connecting client</li>
      </ul>
    </p>
    <p id="socketDisconnected">
      <b class="header">socketDisconnected</b><code>Subscribe("socketDisconnected", function (data) {})</code>
      data object contains:
      <ul>
        <li>socketId: string.  Socket ID of disconnecting client</li>
      </ul>
    </p>
    <p id="messageFromClient">
      <b class="header">messageFromClient</b><code>Subscribe("messageFromClient", function (data) {})</code>
      data object contains:
      <ul>
        <li>socketId: string.  Socket ID of connecting client</li>
        <li>type: string.  category of message</li>
        <li>message: js object.</li>
      </ul>
    </p>
    <p id="messageToClient">
      <b class="header">messageToClient</b><code>Publish("messageToClient", messageObject)</code>
      <br />
      sends a message to the client.  messageObject Structure:
      <ul>
        <li>socketId: string</li>
        <li>type: string</li>
        <li>message: JS object</li>
      </ul>
    </p>
    <p id="broadcast">
      <b class="header">broadcast</b><code>Publish("broadcast", messageObject)</code>
      <br />
      sends a message to all connected clients.  messageObject Structure:
      <ul>  
        <li>message: JS object</li>
      </ul>
    </p>
    <h2>Client Side API</h2>
    <p id="messageToServer">
      <b class="header">messageToServer</b><code>Publish("messageToServer", messageObject)</code>
      <br />
      sends a message to server.  messageObject Structure:
      <ul>  
        <li>message: JS object</li>
        <li>type: string.  type or category of message</li>
      </ul>
    </p>
    <p id="messageFromServer">
      <b class="header">messageFromServer</b><code>Subscribe("messageFromServer", messageObject)</code>
      <br />
      sends a message to server.  messageObject Structure:
      <ul>  
        <li>message: JS object</li>
        <li>type: string.  type or category of message</li>
      </ul>
    </p>
    <h2>Common</h2>
    <p id="addEntity">
      <b class="header">addEntity</b><code>Publish("addEntity", entity)</code>
      <br />
      Takes an entity and adds it to the physics engine simulation.  Note this should only be done server-side.  If done client-side ( lets say for client-side prediction), the local entity will be removed upon the next snapshot from the (authorative) server.  An entity will be an instance of the entity class (or subclass) found in in crystal/common/entity.js
    </p>
    <p id="removeEntity">
      <b class="header">removeEntity</b><code>Publish("removeEntity", entity)</code>
      <br />
      Removes an entity from the physics engine simulation.  Note this should only be done server-side.  If done client-side ( lets say for client-side prediction), the local entity will be brought back upon the next snapshot from the (authorative) server.  An entity will be an instance of the entity class (or subclass) found in in crystal/common/entity.js
    </p>
    <p id="update">
      <b class="header">update</b><code>Subscribe("update", data)</code>
      <br />
      The update is published sixty times per second.  The data object includes the tick count, so if you want something to happen three times per second you could do: <code>if(data.tickCount % 20 === 0)</code>
    </p>

  </section>
 </body>
</html>